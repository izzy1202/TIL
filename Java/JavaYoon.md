# <윤성우의 열혈 Java> 강의 내용 정리
>[강의 링크](https://cafe.naver.com/cstudyjava/135782?boardType=L)
>
>모든 내용을 정리하지는 않음

---

# Chapter 01

## 1. 자바 프로그램과 실행의 원리에 대한 이해

### 1.1. 일반적 프로그램과 자바 프로그램의 차이

#### 일반 프로그램
하드웨어의 운영체제가 프로그램을 실행

#### 자바 프로그램
- 하드웨어의 운영체제가 프로그램을 실행하는 것까지는 일반 프로그램과 동일
- 자바 프로그램이 실행되기 위해서는 Java Virtual Machine 이라는 가상머신이 먼저 실행되어야 함
  (자바 프로그램은 JVM에 완전히 종속되어서 실행되는 구조)
- 자바 런처(java.exe)는 JVM을 실행시키고 그 위에 자바 프로그램을 올려준다.

### 1.2. 운영체제에 따른 자바 가상머신의 차이
- 자바는 한 번 프로그램을 작성하면 운영체제에 상관없이 동작시킬 수 있다.

### 1.3. 자바 컴파일러와 자바 바이트코드

#### 자바 컴파일러(javac.exe)
- 소스파일(소스코드 존재하는 파일) -- 컴파일러 역할 --> 클래스 파일(바이트코드 존재하는 파일)
- 소스파일 : 우리가 알아볼 수 있는 문장
- 클래스 파일 : 소스파일을 JVM이 알아볼 수 있는 문장으로 바꾼 것
- cf. 바이트코드 : 명령문

#### 자바 런처(java.exe)
- 자바 프로그램과 자바 가상머신을 처음 구동하는 소프트웨어
- 클래스 파일을 대상으로 구동을 시작한다.

## 2. 첫 번째 자바 프로그램의 관찰과 응용

### 2.1. 프로그램의 골격과 구성

- 중괄호를 이용해서 클래스와 메소드의 영역을 구분
- 문장(명령문)의 끝에는 세미콜론을 붙여서 문장의 끝 표시
- 프로그램 실행 시 main 메소드 안 문장들 순차적 실행
- System.out.println의 괄호 안에 출력 내용 큰따옴표로 묶어서 표시
- System.out.println 실행 이후 자동 개행


# Chapter 02

## 1. 변수의 이해와 활용

### 1.1. 메모리 공간 할당의 예

#### 1.1.1. 변수 선언을 통해 결정하는 2가지
1) 변수의 이름
2) 변수의 용도

### 1.2. 다양한 자료형 활용의 예
- 자료형은 데이터를 표현, 해석하는 방법
- 두 개의 변수 동시 선언 가능하나, 한 문장에서 하나의 변수를 선언하는 것이 좋다고 여겨짐

### 1.3. 변수 이름 제약사항
1) 자바는 대소문자를 구분한다.
2) 변수의 이름은 숫자로 시작할 수 없다.
3) $와 _이외의 특수문자는 사용할 수 없다.
4) 키워드는 변수의 이름으로 사용할 수 없다.
- 키워드 : 자바의 문법을 구성하는 약속된 예약어
   ex) int, double ...

## 2. 실수의 표현 방식 이해하기
- 정수와 달리 실수는 오차 없이 표현이 불가능

## 3. 자바의 기본 자료형

### 3.1. 정수 자료형

#### 3.1.1. int형 변수를 선택해야 하는 이유
- 기본적으로 자바는 정수형 사칙연산을 할 때 int 자료형으로 진행한다.
-> 규모를 JVM이 각각 판단을 하게 되어버리면 시스템 성능 저하로 이어진다.
- int형으로 설정하게 되면 시스템 성능 저하될 일 없다.
- cf. 데이터의 크기가 너무 많고, 연산이 중심이 되는 게 아니라 저장에 의미가 있는 경우에는 byte나 short를 쓸 수도 있다.

### 3.2. 실수 자료형
- 기본적으로 자바는 실수형 사칙연산을 할 때 double 자료형으로 진행한다.
- float와 double 사이에서의 자료형 선택 기준은 정밀도이다.
-> 바이트가 더 큰 것은 오차없이 표현할 수 있는 값의 크기가 크다는 것

### 3.3. 문자 자료형
- 자바의 문자 자료형은 char
- 자바는 문자를 2바이트 유니코드로 표현한다.
- 작은 따옴표로 묶어서 하나의 문자를 표시한다.
- 문자의 저장은 유니코드 값의 저장으로 이어진다.

### 3.4. 논리 자료형

# Chapter 03

## 1. 상수(Constants)

### 1.1. 자바의 일반적인 상수

#### 1.1.1. 자바에서 말하는 '상수'
- 상수는 변수에 값을 딱 한 번만 할당할 수 있다
- 한 번 할당된 값은 변경이 불가능하다
- 키워드 final 선언이 붙어있는 변수

#### 1.1.2. final 기반의 상수 선언의 예
- 상수의 이름은 모두 대문자로 짓는 것이 관례
- 이름이 둘 이상의 단어로 이뤄질 경우 단어를 언더바로 연결하는 것이 관례

### 1.2. 리터럴(Literals)에 대한 이해
- 리터럴 : 자료형을 기반으로 표현이 되는 상수를 의미한다.
ex) int num1 = 5 + 7;
ex) double num2 = 3.3 + 4.5;
- 정수는 무조건 int형으로 인식하기로 약속되어 있음
- 따라서 5와 7은 '정수형 리터럴'이다.
- 그리고 3.3과 4.5는 '실수형 리터럴'이다.
- '리터럴'이라는 표현은 '상수'라는 표현으로 대신하는 경우가 많다.

### 1.3. 정수형 상수(리터럴)의 표현 방법
~~~java
  int num1 = 123;    // 10진수 표현
  int num2 = 0123;   // 8진수 표현
  int num3 = 0x123;  // 16진수 표현
~~~

### 1.4. long형 상수(리터럴)의 표현 방법
~~~java
  System.out.println(3147483647 + 3147483648);
~~~
- 컴파일시 Integer number too large 라는 오류 메시지를 전달한다.
~~~java
  System.out.println(3147483647L + 3147483648L);
~~~
- l 또는 L을 붙여서 long형 상수로 표현해 달라는 요청을 해야 한다.

### 1.5. 정수형 상수의 이진수 표현방법과 언더바 삽입
~~~java
  byte seven = 0B111;
  int num205 = 0B11001101;
~~~
- 0B 또는 0b를 붙여서 이진수 표현
~~~java
  int num = 100_000_000;
  int num = 12_34_56_78_90;
~~~

### 1.6. 실수형 상수(리터럴)
~~~java
  System.out.println(3.0004999 + 2.0004999);
  System.out.println(3.0004999D + 2.0004999D);
~~~
- 실수는 기본 double형 double형임을 명시하기 위해 d 또는 D 삽입
가능
-> 잘 쓰지는 않음
~~~java
  System.out.println(3.0004999f + 2.0004999f);
~~~
- 실수형 상수를 float형으로 표현하려면 f 또는 F 삽입
-> 메모리 공간은 적게 쓰겠지만 오차의 크기가 커진다.

#### 1.6.1. 실수형 상수의 e 표기법
~~~java
  3.4e3  -> 3.4 x 10^3 = 3400.0
  3.4
~~~

### 1.7. 이스케이프 시퀀스(escape sequences)
- 화면상의 어떠한 상황 또는 상태를 표현하기 위해 약속된
문자
- '\r' : 캐리지 리턴(carriage return) 문자로, 커서가 맨 앞으로 이동

## 2. 형 변환

### 2.1. 자료형 변환의 의미와 필요한 이유는?
- 두 피연산자의 자료형이 일치해야 동일한 방법을 적용하여 연산을 진행할 수 있다.
- 피연산자의 자료형이 일치하지 않을 때 형(Type)의 변환을 통해 일치시켜야 한다.

### 2.2. 자동 형 변환(Implicit Conversion)
- 규칙 1. 자료형의 크기가 큰 방향으로 형 변환이 일어난다.
- 규칙 2. 자료형의 크기에 상관없이 정수 자료형보다 실수 자료형이 우선한다.
- cf. float가 long보다 우선시되는 이유
: 데이터 손실을 최소화하기 위해 정수보다 실수가 우선하는데, float 자료형은 표현할 수 있는 범위가 넓다.
반면, long 자료형은 소수점 이하는 표현 못한다. 따라서 float 자료형을 long 자료형으로 형 변환하게 되면 소수점 이하는 사라진다.

### 2.3. 명시적 형 변환(Explicit Conversion)
- 자동 형 변환 규칙에 부합하지는 않지만, 형 변환이 필요한 상황이면 명시적 형 변환을 진행한다.

# Chapter 04

## 1. 자바에서 제공하는 이항 연산자들
- 하나의 문장 안에 둘 이상의 연산자가 존재할 경우, 연산자의 우선순위를 적용해서 연산 순서를 정한다. 연산자의 우선순위가 같을 경우 결합 방향을 적용하여 연산 순서 결정한다.

### 1.1. 정수형 나눗셈과 실수형 나눗셈
- 피연산자의 자료형이 무엇이냐에 따라서 나눗셈의 형태가 달라진다.

### 1.2. 복합 대입 연산자
- 복합 대입 연산자를 쓸 경우, 자바 프로그램이 그 문장을 해석하는 과정에서 필요로 하는 강제 형변환을 알아서 해주기도 한다.
-> 하지만 좋지 않은 코드. 강제 형변환을 해주는 것이 명확하다.

### 1.3. 관계 연산자
- 관계 연산자의 결과는 true / false 이다.
~~~java
  System.out.println("7.0 == 7 : " + (7.0 == 7)); //7.0 == 7 : true
~~~
-> 원래라면 두 피연산자의 자료형이 달라서 비교 불가지만, 7(int)이 7.0(double)로 자동 형변환된다.

### 1.4. 논리 연산자
- 피연산자도 true / false여야 한다.
- cf. num = 2 + 3 일때, 5가 num에 한번에 들어가는 것이 아니라 연산이 이루어지고 결과가 반환되어서 그 연산문을 대체하게 되고 그 다음 대입이 이루어지게 된다고 생각하는 것이 좋다.

### 1.5. 논리 연산자 사용시 주의점 : SCE
- 하나의 문장에 너무 많은 내용을 담기 보다는 따로 떼어서 쓰는 것이 낫다.
~~~java
  result = ((num1 += 10) < 0) && ((num2 += 10) > 0);
  result = ((num1 += 10) > 0) || ((num2 += 10) > 0);
~~~
-> num1 , num2의 값을 모두 증가시키기 위해서는 독립된 문장으로 쓰는 것이 낫다.

## 2. 자바에서 제공하는 단항 연산자들
- 부호 연산자 –는 변수에 저장된 값의 부호를 바꾸어 반환한다.
- 부호 연산자로서의 + 연산자도 연산자로서의 의미는 갖는다.

## 3. 비트를 대상으로 하는 연산자들
- 비트 연산자를 잘 사용하면 코드를 조금 더 그럴듯 하게 만들 수 있다.
- 잘 안쓰는 연산자로 치부하지 말기

### 3.1. 비트 연산자의 이해
- 비트 연산자의 피연산자는 정수로 제안이 되어있다.

![image](https://user-images.githubusercontent.com/106478906/230700743-f8b57770-ff45-4f61-a2f0-44471e82aabd.png)

-> n1 n2를 byte로 선언했어도 연산하는 과정에서 int형으로 변환되기 때문에 n3에 저장하려면 byte로 강제형변환을 해야한다.

### 3.2. 비트 연산자
- 뒤에서부터 첫 번째 비트
- ^ : 비트 단위로 XOR 연산, 비트 A와 비트 B가 서로 달라야 1
- ~ : 피연산자의 모든 비트를 반전시킴 

### 3.3. 비트 쉬프트 연산자
![image](https://user-images.githubusercontent.com/106478906/230701349-421294f2-7fe7-4e38-8e78-7b4900287807.png)
-> 두 칸 왼쪽으로 이동시키면 제일 오른쪽에 두 칸이 남게되고, 제일 왼쪽의 두 칸의 값은 버려진다.
-> n이 저장하고 있는 값을 미는 것이 아니라, 밀어서 얻어진 결과를 하나의 결과로 만들어 낼 뿐이다.
-> n이 가진 값 자체가 바뀌는 것은 아니다.
- '>>' : 가장 왼쪽 비트가 음수/양수냐에 따라서 결정
- '>>>' : 가장 왼쪽 비트에 상관없이 0으로 채운다.
- 왼쪽으로의 쉬프트는 값의 2배 증가, 오른쪽으로의 쉬프트는 값을 2로 나눈 결과로 이어진다.
- cf. 특정 시스템의 CPU가 떨어지는 경우가 있는데, 곱셈/나눗셈이 덧셈/뺄셈에 비해 CPU를 많이 차지한다. 시스템 성능이 떨어지는 경우에는 프로그래머들이 그런 것도 고려해서 곱셈/나눗셈 대신 이런 비트 연산자를 사용하기도 한다.

# Chapter 05

## 1. if 그리고 else

### 1.1. if문
- if문에 속한 문장이 하나일 경우 중괄호 생략 가능
-> 프로그래머들은 불필요한 것을 최소화하는 것을 좋아하기 때문에 이것에 익숙해지는 것이 낫다.(들여쓰기로 구분)

### 1.2. if ~ else문
- if문과 마찬가지로 if절 또는 else 절에 속한 문장이 하나일 경우 중괄호 생략 가능

### 1.3. if ~ else if ~ else 문
- else if 절, 중간에 얼마든지 추가 가능

### 1.4. if ~ else문과 유사한 성격의 조건 연산자(3항 연산자)
![image](https://user-images.githubusercontent.com/106478906/230704382-b1a50be8-02ff-4752-b5e4-861036f59804.png)
- 값이 와야하는 위치에 상수나 변수만 써야 하는 것이 아니라, 값을 반환하는 연산도 올 수 있다.

## 2. switch와 break

### 2.1. switch문의 기본 구성
- case와 default는 레이블
-> 실행 위치를 표시하는 용도로 사용된다.
- default : 해당하는 case 없으면 실행
- cf. switch문은 들어가는 문장들이 많기 때문에 대부분 중괄호를 사용한다.
- cf. case는 레이블이라는 상징적 의미로 들여쓰기를 하지 않는다.

### 2.2. switch문 + break문
- break문이 실행되면 switch문을 빠져나간다.

![image](https://user-images.githubusercontent.com/106478906/230704932-b177a197-7065-43cd-8cfa-ba229b585171.png)

-> 한 페이지에 여러 개의 인덱스를 붙여놓는 것과 같다.

## 3. for, while 그리고 do~while 
- 서로 바꿔보는 연습 하기
- 반복 
  - 횟수 : for
  - 만족 : while

### 3.1. while문과 do ~ while문의 차이
- while문은 조건 검사를 먼저하고 실행, do ~ while문은 일단 실행하고 조건 검사
![image](https://user-images.githubusercontent.com/106478906/230707171-be9773cf-37a5-4eb8-9067-dc41872bff1a.png)

![image](https://user-images.githubusercontent.com/106478906/230709199-d88c3e22-9553-431a-92ee-5fbb94c4c131.png)
- 1번 시작하고 2-3-4 삼각형 반복된다고 생각하면 쉬움

## 4. break & continue 
![image](https://user-images.githubusercontent.com/106478906/230709635-7dce3a06-6ba1-4d05-aec5-5e976a7e74e4.png)

- break : 빠져나가라
- continue : 계속은 계속인데 위에서부터 계속
  - 남은 거 생략하고 위에부터 다시 시작한다

### 4.1. 무한루프
~~~java
  for( ; ; ) {
      ....
  }
~~~
~~~java
  while(true){
      ....
  }
~~~
~~~java
  do{
      ....
  } while(true)
~~~
- 특정 조건이 만족되었을 때 반복문을 벗어나려면 break문을 실행하면 된다.

## 5. 반복문의 중첩
![image](https://user-images.githubusercontent.com/106478906/230723370-b7414b69-2b9e-488a-af3a-aa828534cf8a.png)
- for문 중첩이 가장 중요
![image](https://user-images.githubusercontent.com/106478906/230726318-11daef6d-9e44-4207-abff-90d4048132d9.png)

# Chapter 06

## 1. 메소드에 대한 이해와 메소드의 정의
- 메소드 = 기능 상자
- 클래스에 여러 기능 상자를 담음

### 1.1. main 메소드
- 자바에서 정한 규칙: 프로그램의 시작은 main에서부터

### 1.2. 매개변수 0개, 2개인 메소드
- 자바의 기능상자는 입/출력이 있을수도 있고 없을수도 있다.
- 매개변수가 없는 메소드의 정의
~~~java
  public static void byEveryone(){
      System.out.println("다음에 뵙겠습니다.");
  }
~~~

### 1.3. 값을 반환하는 메소드
- void: 값을 반환하지 않음을 의미
- return: 값의 반환을 명령
  - 메소드를 호출한 영역으로 전달
  - 메소드 호출문을 그 결과로 대체한다
![image](https://user-images.githubusercontent.com/106478906/230756291-56bb33e6-61bc-4d81-849a-98247addb9c1.png)
- 반환하는 값과 자료형을 일치시켜야 한다.(jvm에게 반환할 자료에 대한 정보 알려주는 것)

### 1.4. return의 두 가지 의미
1) 메소드를 호출한 영역으로 값을 반환
2) 메소드의 종료

## 2. 변수의 스코프  
- 지역 변수 : 지역은 중괄호 안을 의미
![image](https://user-images.githubusercontent.com/106478906/230757112-5e38b416-d845-4aa3-b2e9-56c7bc40279b.png)

-> for문 내에서 유효한 지역변수 num
- 매개 변수 : 지역변수의 범주에 포함된다
  - 속한 영역을 벗어나면 지역변수 소멸
  
### 2.1. 지역변수 선언의 예
- 같은 영역 내에서 동일 이름의 변수 선언 불가

## 3. 메소드의 재귀 호출
- 돌아간다고 생각하지 말고, 사본 메소드를 만들어놓고 그걸 호출한다고 생각하면 쉬움
![image](https://user-images.githubusercontent.com/106478906/230758142-332fec66-772c-4f1a-877e-1d79e4a0ef68.png)
![image](https://user-images.githubusercontent.com/106478906/230758419-4a6f28e3-d916-4413-aac0-1e9a49b4c02b.png)

-> 3단계에서 1이 2단계로 반환되고 2단계에서 2가 1단계로 반환되어 결과가 3*2 = 6 이다.

# Chapter 07

## 1.클래스의 정의와 인스턴스의 생성

### 1.1. 프로그램의 기본 구성
- 클래스는 연관된 데이터와 메소드를 묶는다.
- 하나의 클래스를 만든다는 것은 틀을 만든다는 것이고, 그 자체로 기능을 가진 것은 아니다.
- 그 틀을 기반으로 인스턴스를 만들어내야 실제로 변수도 존재하게 되고 메소드도 호출 가능하게 되는 것이다.

### 1.2. 클래스 = 데이터 + 기능
- new ~ : 인스턴스를 만들어라.
![image](https://user-images.githubusercontent.com/106478906/230759863-c67de628-ab01-44c1-85ee-5b15fe432e27.png)

-> BackAccount라는 틀을 이용해서 인스턴스를 만들어라.

### 1.3. 인스턴스와 참조변수
- 참조 변수 : 인스턴스의 정보를 갖기 위해 필요한 것
  - 인스턴스가 생성될 때 반환되는 주소값을 저장하기 위한 변수
  - 이 참조 변수를 통해서 우리가 호출하고자 하는 메소드(접근하고자 하는 인스턴스)를 결정할 수 있다.
  
### 1.4. 참조변수의 특성
1) 참조변수는 참조하는 인스턴스를 바꿀 수 있다.
2) 서로 다른 참조변수가 같은 인스턴스를 참조할 수 있다. 

### 1.5. 참조변수의 매개변수 선언
![image](https://user-images.githubusercontent.com/106478906/230762260-d1ac9428-1acd-43a8-aefb-0d8fbad6ba80.png)

-> 참조변수 ref 가 참조하는 인스턴스의 주소 값을 참조변수 acc에 전달하는 것
- 주소 값 = 참조 값

### 1.6. 참조변수에 null 대입
- null은 청소부
~~~java
  ref = null; // ref가 참조하는 인스턴스와의 관계를 끊음
  if(ref == null) // ref가 참조하는 인스턴스가 없다면
~~~

























